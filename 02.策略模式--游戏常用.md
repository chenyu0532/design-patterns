```
典型应用：角色的各个属性计算；游戏有多种的登录方式

大体意思为：定义一个Strategy(策略接口类)，可以有StrategyA~StrategyC(策略实现类)等子类

　ICharacterAttr　　声明游戏内使用的角色属性,访问方法和声明攻击流程中所需要的方法,并拥有一个IAttrStrategy对象,通过该对象来调用真正的计算公式
　　IAttrStrategy　　声明角色属性计算的接口方法,用来把ICharacterAttr与计算方法分离,让ICharacterAttr可轻易地更换计算策略
　　EnemyAttrStrategy　　实现敌方阵营单位在攻击流程中所需要的各项公式的计算
　　SoldierAttrStrategy　　实现玩家阵营单位在攻击流程中所需要的各项公式的计算

public abstract class IAttrStrategy {
    // 初始的属性
    public abstract void InitAttr(ICharacterAttr CharacterAttr);
    // 攻击加成
    public abstract int GetAtkPlusValue(ICharacterAttr CharacterAttr);
    // 获取减少伤害值
    public abstract int GetDmgDescValue(ICharacterAttr CharacterAttr);
}

public class SoldierAttrStrategy: IAttrStrategy {
    public override void IniAttr(ICharacterAttr CharacterAttr) {
        SoliderAttr theSoliderAttr = CharacterAttr as SoliderAttr;
        if (theSoldierAttr == null) {
            return;
        }

        int AddMaxHP = 0;
        int Lv = theSoldierAttr.GetSoldierLv();
        if (Lv > 0) {
            AddMaxHP = (Lv - 1) *2;
        }
        theSoldierAttr.AddMaxHP(AddMaxHP);
    }

    public override int GetAtkPlusValue(ICharacterAttr CharacterAttr) {
        return 0;
    }

    public override int GetDmgDescValue(ICharacterAttr CharacterAttr) {
        SoliderAttr theSoliderAttr = CharacterAttr as SoldierAttr;
        if (theSoliderAttr == null) {
            return 0;
        }
        return (theSoliderAttr.GetSoldierLv() - 1) * 2;
    }
}

public class EnemyAttrStrategy: IAttrStrategy {
    public override void InitAttr(ICharacterAttr CharacterAttr) {
        EnemyAttr theEnemyAttr = CharacterAttr as EnemyAttr;
        if (theEnemyAttr == null) {
            return 0;
        }

        int RandValue = UnityEngine.Random.Range(0, 100);
        if (theEnemyAttr.GetCritRate() >= RandValue) {
            theEnemyAttr.CutdownCritRate();
            return theEnemyAttr.GetMaxHP() * 5;
        }
        return 0;
    }

    public override int GetDmgDescValue(ICharacterAttr CharacterAttr) {
        return 0;
    }
}

public abstract class ICharacterAttr {
    protected int m_MaxHP = 0;
    protected int m_NowHP = 0;
    protected float m_MoveSpeed = 1.0f;
    protected string m_AttrName = "";

    protected IAttrStrategy m_AttrStrategy = null;

    public void SetAttStrategy(IAttrStrategy theAttrStrategy) {
        m_AttrStrategy = theAttrStrategy;
    }

    public IAttrStrategy GetAttrStrategy() {
        return m_AttrStrategy;
    }

    public virtual void InitAttr() {
        m_AttrStrategy.InitAttr(this);
        FullNowHP();
    }

    public int GetAtkPlusValue() {
        return m_AttrStrategy.GetAtkPlusValue(this);
    }

    public void CalDmgValue(ICharacter Attacker) {
        int AtkValue = Attacker.GetAtkValue();
        AtkValue -= m_AttrStrategy.GetDmgDescValue(this);
        m_NowHP -= AtkValue;
    }
}

public abstract class ICharacter {
    ...
    private IWeapon m_Weapon = null;
    protected ICharacterAttr m_Attribute = null;
    
    public virtual void SetCharacterAttr(ICharacterAttr CharacterAttr) {
        m_Attribute = CharacterAttr;
        m_Attribute.InitAttr();

        m_NavAgent.speed = m_Attribute.GetMoveSpeed();
        
        m_Name = m_Attribute.GetAttrName();
    }

    public void Attack(ICharacter Target) {
        SetWeaponAtkPlusValue(m_Attribute.GetAtkPlusValue());
        WeaponAttackTarget(Target);
    }

    public void Attack(ICharacter theTarget) {
            m_Weapon.SetAtkPlusValue(m_Attribute.GetAtkPlusValue());
        m_Weapon.Fire(theTarget);
    }

    public void UnderAttack(ICharacter Attacker) {
        m_Attribute.CalDmgValue(Attacker);
        if (m_Attribute.GetNowHP() <= 0) {
            Debug.Log("角色阵亡");
        }
    }
}

